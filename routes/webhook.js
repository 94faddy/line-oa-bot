const express = require('express');
const router = express.Router();
const crypto = require('crypto');

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏µ‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
function containsKeyword(text, keywords) {
  if (!text) return false;
  const lowerText = text.toLowerCase();
  return keywords.some(keyword => 
    lowerText.includes(keyword.toLowerCase())
  );
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
function canSendMessage(userId, userMessageHistory, getCooldownPeriod) {
  const lastSentTime = userMessageHistory.get(userId);
  if (!lastSentTime) return true;
  
  const currentTime = Date.now();
  const timeDiff = currentTime - lastSentTime;
  return timeDiff >= getCooldownPeriod();
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
function recordMessageSent(userId, userMessageHistory) {
  userMessageHistory.set(userId, Date.now());
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
function getRemainingTime(userId, userMessageHistory, getCooldownPeriod) {
  const lastSentTime = userMessageHistory.get(userId);
  if (!lastSentTime) return 0;
  
  const currentTime = Date.now();
  const timeDiff = currentTime - lastSentTime;
  const remaining = getCooldownPeriod() - timeDiff;
  
  return remaining > 0 ? remaining : 0;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏°‡∏¥‡∏•‡∏•‡∏¥‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡πÅ‡∏•‡∏∞‡∏ô‡∏≤‡∏ó‡∏µ
function formatTime(milliseconds) {
  const hours = Math.floor(milliseconds / (1000 * 60 * 60));
  const minutes = Math.floor((milliseconds % (1000 * 60 * 60)) / (1000 * 60));
  return `${hours} ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á ${minutes} ‡∏ô‡∏≤‡∏ó‡∏µ`;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Cooldown ‡∏û‡∏£‡πâ‡∏≠‡∏° placeholder
function getCooldownMessage(userId, cooldownMessageTemplate, userMessageHistory, getCooldownPeriod) {
  const remaining = getRemainingTime(userId, userMessageHistory, getCooldownPeriod);
  const timeLeft = formatTime(remaining);
  const template = cooldownMessageTemplate || "‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠ {timeLeft} ‡∏Å‡πà‡∏≠‡∏ô‡∏Ç‡∏≠‡∏£‡∏±‡∏ö‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏∞‡∏Ñ‡∏∞ üòä";
  return template.replace('{timeLeft}', timeLeft);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤ LINE Client ‡∏à‡∏≤‡∏Å signature
function findClientBySignature(signature, body) {
  for (const [channelId, clientData] of global.lineClients.entries()) {
    const hash = crypto
      .createHmac('SHA256', clientData.channelSecret)
      .update(body)
      .digest('base64');
    
    if (hash === signature) {
      return {
        client: clientData.client,
        channelId: channelId,
        config: clientData.config
      };
    }
  }
  return null;
}

// Setup Webhook Route
function setupWebhookRoute(
  appConfig, 
  userMessageHistory, 
  getCooldownPeriod, 
  containsPromotionKeyword, 
  createPromotionFlexMessage, 
  getRandomFlex, 
  getQuickReplyMenu,
  containsQuickReplyKeyword,
  containsFlexKeyword,
  quickReplyConfig
) {
  
  router.post('/webhook', express.json(), async (req, res) => {
    try {
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ LINE Channel ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      if (global.lineClients.size === 0) {
        console.log('‚ö†Ô∏è Webhook received but no LINE channels are configured');
        return res.status(200).send('No channels configured');
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö signature
      const signature = req.get('x-line-signature');
      if (!signature) {
        console.log('‚ùå No signature provided');
        return res.status(401).send('No signature');
      }

      // ‡∏´‡∏≤ LINE Client ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö signature
      const body = JSON.stringify(req.body);
      const clientData = findClientBySignature(signature, body);

      if (!clientData) {
        console.log('‚ùå Invalid signature - no matching channel found');
        return res.status(401).send('Invalid signature');
      }

      console.log(`‚úÖ Webhook verified for channel: ${clientData.config.name} (${clientData.channelId})`);

      const events = req.body.events;
      await Promise.all(events.map(event => 
        handleEvent(
          event, 
          clientData.client,
          clientData.config,
          appConfig, 
          userMessageHistory, 
          getCooldownPeriod, 
          containsPromotionKeyword, 
          createPromotionFlexMessage, 
          getRandomFlex, 
          getQuickReplyMenu,
          containsQuickReplyKeyword,
          containsFlexKeyword,
          quickReplyConfig
        )
      ));
      
      res.status(200).send('OK');
    } catch (err) {
      console.error('Error in webhook:', err);
      res.status(500).send('Internal Server Error');
    }
  });

  return router;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Event
async function handleEvent(
  event, 
  lineClient,
  channelConfig,
  appConfig, 
  userMessageHistory, 
  getCooldownPeriod, 
  containsPromotionKeyword, 
  createPromotionFlexMessage, 
  getRandomFlex, 
  getQuickReplyMenu,
  containsQuickReplyKeyword,
  containsFlexKeyword,
  quickReplyConfig
) {
  if (event.type !== 'message' || event.message.type !== 'text') {
    return null;
  }
  
  if (!lineClient) {
    console.error('LINE client not available');
    return null;
  }
  
  const userId = event.source.userId;
  const messageText = event.message.text;
  
  console.log(`üì© [${channelConfig.name}] Received message from ${userId}: ${messageText}`);
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Features ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á Channel ‡∏ô‡∏µ‡πâ
  const features = channelConfig.features || {
    activities: true,
    promotions: true,
    flexMessages: true
  };

  console.log(`üîß [${channelConfig.name}] Features:`, features);
  
  // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î‡πÇ‡∏õ‡∏£‡πÇ‡∏°‡∏ä‡∏±‡πà‡∏ô‡∏Å‡πà‡∏≠‡∏ô (‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
  if (features.promotions && containsPromotionKeyword(messageText)) {
    console.log(`üé® [${channelConfig.name}] Promotion keyword detected!`);
    
    const flexMessage = createPromotionFlexMessage();
    
    if (flexMessage) {
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: [flexMessage]
      });
      console.log(`‚úÖ [${channelConfig.name}] Promotions sent to ${userId}`);
    } else {
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: [{
          type: 'text',
          text: '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏õ‡∏£‡πÇ‡∏°‡∏ä‡∏±‡πà‡∏ô‡∏û‡∏¥‡πÄ‡∏®‡∏© üòä'
        }]
      });
    }
    
    return null;
  }
  
  // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÅ‡∏ä‡∏£‡πå (‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
  if (features.activities && containsKeyword(messageText, appConfig.botSettings.keywords)) {
    console.log(`üéÅ [${channelConfig.name}] Activity keyword detected!`);
    
    if (canSendMessage(userId, userMessageHistory, getCooldownPeriod)) {
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: [{
          type: 'text',
          text: appConfig.botSettings.activityMessage
        }]
      });
      
      recordMessageSent(userId, userMessageHistory);
      console.log(`‚úÖ [${channelConfig.name}] Activity sent to ${userId}`);
    } else {
      const cooldownMsg = getCooldownMessage(userId, appConfig.botSettings.cooldownMessage, userMessageHistory, getCooldownPeriod);
      
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: [{
          type: 'text',
          text: cooldownMsg
        }]
      });
      
      const remaining = getRemainingTime(userId, userMessageHistory, getCooldownPeriod);
      const timeLeft = formatTime(remaining);
      console.log(`‚è≥ [${channelConfig.name}] Cooldown active for ${userId}, ${timeLeft} remaining`);
    }
    
    return null;
  }
  
  // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î Flex Message (‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
  if (features.flexMessages && containsFlexKeyword(messageText)) {
    console.log(`üí¨ [${channelConfig.name}] Flex Message keyword detected!`);
    
    try {
      const randomFlex = getRandomFlex();
      
      if (!randomFlex) {
        await lineClient.replyMessage({
          replyToken: event.replyToken,
          messages: [{
            type: 'text',
            text: '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ Flex Message'
          }]
        });
        return null;
      }

      const messages = [
        {
          type: 'flex',
          altText: 'üìä ‡πÄ‡∏Å‡∏°‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏ä‡∏ô‡∏∞‡∏™‡∏π‡∏á',
          contents: randomFlex
        }
      ];

      // ‡∏™‡πà‡∏á Quick Reply ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö Flex ‡∏ñ‡πâ‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÑ‡∏ß‡πâ
      if (quickReplyConfig.flexMessageSettings.sendWithQuickReply) {
        const quickReply = getQuickReplyMenu();
        if (quickReply) {
          messages.push(quickReply);
        }
      }
      
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: messages
      });
      
      console.log(`‚úÖ [${channelConfig.name}] Flex Message ${quickReplyConfig.flexMessageSettings.sendWithQuickReply ? '+ Quick Reply' : ''} sent to ${userId}`);
    } catch (error) {
      console.error(`‚ùå [${channelConfig.name}] Error sending Flex Message:`, error);
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: [{
          type: 'text',
          text: '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•'
        }]
      });
    }
    
    return null;
  }
  
  // 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î Quick Reply Menu (‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Flex Messages)
  if (features.flexMessages && containsQuickReplyKeyword(messageText)) {
    console.log(`üîò [${channelConfig.name}] Quick Reply keyword detected!`);
    
    const quickReply = getQuickReplyMenu();
    
    if (quickReply) {
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: [quickReply]
      });
      console.log(`‚úÖ [${channelConfig.name}] Quick Reply Menu sent to ${userId}`);
    } else {
      await lineClient.replyMessage({
        replyToken: event.replyToken,
        messages: [{
          type: 'text',
          text: '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ Quick Reply Menu ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'
        }]
      });
    }
    
    return null;
  }
  
  // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÉ‡∏î‡πÜ
  console.log(`‚ÑπÔ∏è [${channelConfig.name}] No matching keyword for message: ${messageText}`);
  return null;
}

module.exports = { setupWebhookRoute };